---
title: การจัดเส้นทาง (Routing)
slug: routing
date: 0005/01/01
number: 5
contents: Learn about routing in Meteor.|Create post discussion pages, with unique URLs.|Learn how to link to those URLs properly.
paragraphs: 72
---

ตอนนี้เราก็มีหน้าเว็บแสดงรายชื่อเรื่องที่โพสต์แล้ว (ซึ่งอีกไม่นาน ผู้ใช้จะโพสต์เรื่องใหม่ได้) ที่เราควรทำคือ เพิ่มหน้าแสดงรายละเอียดเรื่องที่โพสต์แต่ละเรื่องซึ่งผู้ใช้สามารถแสดงความคิดเห็นลงไปได้ด้วย

โดยเราควรทำให้หน้าเหล่านี้เรียกใช้ได้จาก *ลิ้งก์ถาวร (permalink)* ในรูปแบบของ `http://myapp.com/posts/xyz` ซึ่งแต่ละเรื่องที่โพสต์จะมีค่า `xyz` แตกต่างกันไปตามค่าตัวแปร `_id` ของ MongoDB

นั่นก็หมายความว่าเราจำเป็นต้องหาเส้นทางให้แอพ ด้วยข้อมูลจาก URL ที่เบราว์เซอร์กำลังเปิดอยู่ เพื่อแสดงเนื้อหาที่ตรงตามต้องการออกไป 

### เพิ่มแพ็คเกจ Iron Router เข้าไปในแอพ

[Iron Router](https://github.com/EventedMind/iron-router)  เป็นแพ็คเกจจัดการเส้นทางที่เกิดขึ้นมาเพื่อใช้กับแอพของ Meteor โดยเฉพาะ

มันไม่เพียงแต่จะช่วยในเรื่องการจัดเส้นทาง (ตั้งชื่อเส้นทางต่างๆ) แต่ยังช่วยในเรื่องฟิลเตอร์ (กำหนดการทำงานให้กับแต่ละเส้นทาง) และจัดการเรื่องการบอกรับข้อมูลด้วย (ควบคุมว่าเส้นทางไหนเข้าถึงข้อมูลใด)  (หมายเหตุ: Iron Router ถูกพัฒนาบางส่วนโดย Tom Coleman ผู้แต่งร่วมของหนังสือ *Discover Meteor* นี้)

เราเริ่มต้นด้วยการติดตั้งแพ็คเกจจาก Atmosphere

~~~bash
$ meteor add iron:router
~~~
<%= caption "Terminal" %>

โดยคำสั่งนี้จะดาวน์โหลดและติดตั้งแพ็คเกจ Iron Router ลงในแอพเราให้พร้อมใช้งาน ซึ่งบางครั้งคุณอาจต้องรีสตาร์ทแอพใหม่อีกครั้ง (โดยการกด `ctrl+c` เพื่อปิดโปรเซส และเรียก `meteor` เพื่อเริ่มต้นใหม่อีกครั้ง) ก่อนที่จะสามารถใช้งานแพ็คเกจได้

<% note do %>

### คำศัพท์ที่เกี่ยวกับตัวจัดการเส้นทาง (Router)

ในบทนี้เราจะต้องเข้าไปเกี่ยวข้องกับลักษณะต่างๆของตัวจัดการเส้นทาง ซึ่งถ้าคุณเคยมีประสบการณ์กับเฟรมเวิร์คอย่าง Rail มาบ้าง คุณก็คงจะรู้สึกคุ้นเคยกับเรื่องพวกนี้ แต่ถ้าไม่เคยมาก่อน คำอธิบายศัพท์ต่อไปนี้จะช่วยให้คุณเข้าใจได้อย่างรวดเร็ว

- **เส้นทาง (routes)**: คือข้อมูลพื้นฐานของการจัดเส้นทาง ซึ่งก็คือ ชุดคำสั่งที่บอกแอพว่าต้องไปที่ไหน และต้องทำอะไรเมื่อรับค่า URL เข้ามา

- **พาธ (paths)**: คือ URL ภายในแอพของคุณ ที่อาจจะเป็นแบบตายตัว (`/terms_of_service`) หรือแบบปรับเปลี่ยนได้ (`/posts/xyz`) และอาจเป็นแบบที่มีตัวแปรติดมาด้วยก็ได้ (`/search?keyword=meteor`)

- **เซกเมนต์ (segments)**: คือส่วนต่างๆของพาธ  คั่นด้วยเครื่องหมาย `/`

- **ฮุค (hooks)**: คือการทำงานที่คุณต้องการให้มีในระหว่างก่อน, หลัง, หรือตอนที่กำลังเปลี่ยนเส้นทาง ตัวอย่างที่เห็นได้ก็คือ การตรวจสอบสิทธิของผู้ใช้งานว่ามีพอที่จะแสดงหน้าเว็บได้หรือไม่

- **ฟิลเตอร์ (filters)**: จริงๆก็คือฮุคที่คุณกำหนดให้ทำงานกับเส้นทางต่างๆแบบทั่วถึง (global)

- **เทมเพลทเส้นทาง (route templates)**: แต่ละเส้นทางต้องมีเทมเพลท ซึ่งถ้าคุณไม่ได้กำหนดไว้ ตััวจัดการเส้นทางจะมองหาเทมเพลทที่มีชื่อเดียวกับชื่อเส้นทางนั้นโดยอัตโนมัติ

- **เลย์เอาท์ (layout)**: คุณอาจมองเลย์เอาท์ให้เป็น "เฟรม" ของหน้าแอพก็ได้ ซึ่งมันจะประกอบไปด้วยโค้ด HTML ที่หุ้มเทมเพลทไว้อีกชั้น และจะไม่เปลี่ยนแปลงแม้ว่าเทมเพลทจะเปลี่ยนไป

- **คอนโทรลเลอร์ (controller)**: ในบางครั้งคุณอาจจะเห็นว่าเทมเพลทหลายๆตัวต่างก็ใช้งานตัวแปรพารามิเตอร์เหมือนๆกัน ดังนั้นแทนที่จะต้องเขียนโค้ดซ้ำๆกัน คุณอาจจะระบุให้หลายๆเส้นทางที่มีเงื่อนไขจัดการเส้นทางเหมือนกันใช้ *คอนโทรลเลอร์จัดการเส้นทาง* ตัวเดียวกันก็ได้

ถ้าคุณต้องการรายละเอียดที่มากขึ้นเกี่ยวกับ Iron Router คุณควรไปดูที่ [หน้าเอกสารบน GitHub](https://github.com/EventedMind/iron-router) 

<% end %>

### การจัดเส้นทาง : ผูก URL เข้ากับเทมเพลท

ที่ผ่านมาเราได้สร้างเลย์เอาท์ด้วยการเขียนโค้ดลงไปในเทมเพลทด้วยตัวช่วยประเภท include  เช่น `{{>postsList}}` ซึ่งแม้ว่าเนื้อหาในหน้าแอพจะเปลี่ยนแปลงตามข้อมูลได้ แต่โครงสร้างหลักของหน้าก็ยังเหมือนเดิม คือมีหัวเรื่องอยู่บน ตามด้วยรายการชื่อเรื่องที่โพสต์อยู่ข้างล่าง

Iron Router ช่วยให้เราหลุดออกจากกรอบนี้ได้ โดยทำหน้าที่สร้างเนื้อหาภายในแท็ก `<body>` ให้เรา นั่นคือเราไม่ต้องกำหนดแท็กของเนื้อหาเองแบบที่เราเคยทำกับหน้า HTML ทั่วๆไป แต่เราจะบอกตัวจัดการเส้นทางให้ใช้เทมเพลทเลย์เอาท์แบบพิเศษที่มีตัวช่วย `{{>yield}}` อยู่ภายใน

ตัวช่วย `{{>yield}}` นี้จะสร้างพื้นที่พิเศษในหน้าเว็บ และนำเทมเพลทที่ผูกเข้ากับเส้นทางปัจจุบันมาสร้างเนื้อหาให้เราโดยอัตโนมัติ (เพื่อให้เป็นไปตามข้อกำหนด ต่อจากนี้ไปเราจะเรียกเทมเพลทพิเศษตัวนี้ว่า "เทมเพลทเส้นทาง")

<%= diagram "router-diagram", "Layouts and templates.", "pull-center" %>

เราจะเริ่มด้วยการสร้างเลย์เอาท์ที่มีตัวช่วย `{{>yield}}` อยู่ข้างใน โดยแรกสุด ให้เราย้ายแท็ก `<body>` ทั้งชุดออกจากหน้า `main.html` แล้วนำเข้าไปไว้ในเทมเพลทใหม่ชื่อ `layout.html` ที่เราสร้างไว้ในโฟลเดอร์ `client/templates/application`

ซึ่ง Iron Router จะจัดการนำแท็กในเลย์เอาท์มาใส่ใน `main.html` ที่ถูกลดรูปลงเป็นตามที่เห็นนี้ ให้เราโดยอัตโนมัติ :

~~~html
<head>
  <title>Microscope</title>
</head>
~~~
<%= caption "client/main.html" %>

โดยไฟล์ `layout.html` ก็จะประกอบด้วยเลย์เอาท์ของหน้าแอพเราดังนี้ :

~~~html
<template name="layout">
  <div class="container">
    <header class="navbar navbar-default" role="navigation">
      <div class="navbar-header">
        <a class="navbar-brand" href="/">Microscope</a>
      </div>
    </header>
    <div id="main" class="row-fluid">
      {{> yield}}
    </div>
  </div>
</template>
~~~
<%= caption "client/templates/application/layout.html" %>

ให้สังเกตุว่าเราได้เปลี่ยนจากชื่อเทมเพลท `postsList` มาเรียกใช้ตัวช่วย `yield` แล้ว

หลังจากที่เราทำการเปลี่ยนแปลง หน้าเบราว์เซอร์เราก็จะว่างและมีข้อผิดพลาดแสดงในคอนโซลของเบราว์เซอร์ ที่เป็นเช่นนี้เพราะเรายังไม่ได้บอกตัวจัดการเส้นทางว่าให้ทำอะไรเมื่อเปิดใช้แอพที่ URL `/` ดังนั้นมันก็เลยใช้เทมเพลทว่างๆมาแสดงที่หน้าจอ

เพื่อแก้ไขให้หน้าจอกลับมาใช้งานได้เหมือนเดิม เราก็จะผูกพาธที่ `/` เข้ากับเทมเพลท `postsList` โดยเราจะสร้างไฟล์ `router.js` ในโฟลเดอร์ `/lib` ภายในโปรเจกต์ของเรา ดังนี้ :

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.route('/', {name: 'postsList'});
~~~
<%= caption "lib/router.js"%>

จากไฟล์นี้ เราได้ทำเรื่องสำคัญไปสองเรื่อง เรื่องแรกคือ เราบอกตัวจัดการเส้นทางให้ใช้เทมเพลทขื่อ `layout` ที่เราเพิ่งสร้างและใช้เป็นเทมเพลทพื้นฐานของทุกเส้นทาง

เรื่องที่สอง เราได้สร้างเส้นทางใหม่ชื่อ `postsList` และผูกเข้ากับพาธ `/`

<% note do %>

### โฟลเดอร์ `/lib`

ไม่ว่าคุณจะวางไฟล์อะไรไว้ในโฟลเดอร์ `lib` มันจะถูกโหลดมาทำงานเป็นอันดับแรกก่อนไฟล์อื่นๆในแอพของคุณเสมอ (ยกเว้นเฉพาะแพ็คเกจบางประเภทเท่านั้น) ที่ตรงนี้จึงเหมาะกับการวางโค้ดตัวช่วยต่างๆที่จำเป็นต้องเรียกใช้งานได้ตลอดเวลา

มีคำเตือนเล็กๆว่า เนื่องจาก `/lib` ไม่ได้อยู่ใน `/client` หรือ `/server` ก็หมายความว่าอะไรที่อยู่ในนั้นจะเรียกใช้ได้จากทั้งสองฝั่ง

<% end %>

### ชื่อเส้นทาง

เราตั้งชื่อเส้นทางของเราว่า `postsList` และเราก็ยังมี *เทมเพลท* ชื่อ `postsList` อยู่ด้วย ซึ่งคุณอาจจะงงว่าเกิดอะไรขึ้น ดังนั้นเพื่อคลายความสงสัยเราจะมาหาคำตอบกัน

โดยปกติ Iron Router จะมองหาเทมเพลทที่มีชื่อเหมือนกับชื่อเส้นทาง อันที่จริงมันหาจากชื่อพาธที่เราให้ด้วยซ้ำ ซึ่งในกรณีของเราจะหาเทมเพลทไม่ได้ (เพราะว่าพาธเราคือ `/`)  แต่ถ้าเราใช้ `http://localhost:3000/postsList` แทน Iron Router ก็จะหาเทมเพลทให้เราได้

คุณอาจจะสงสัยว่าแล้วทำไมเรายังต้องตั้งชื่อเส้นทางไว้ด้วย การตั้งชื่อเส้นทางช่วยให้เราใช้คุณสมบัติบางอย่างของ Iron Router ที่ทำให้การสร้างลิงก์ต่างๆในแอพง่ายขึ้น โดยตัวช่วยของ Spacebars ที่มีประโยชน์มากที่สุดคือ `{{pathFor}}` ก็ใช้ชื่อเส้นทางในการสร้างลิงก์ของเส้นทางต่างๆให้เราได้ง่ายๆ

ถ้าเราต้องการให้มีลิงก์กลับไปที่หน้าหลักของแอพเพื่อแสดงรายการชื่อโพสต์ เราก็สามารถทำได้โดยใช้ตัวช่วย Spacebars แทนการใช้พาธตายตัวอย่าง `/` โดยผลลัพธ์ที่ได้ยังคงเดิม แต่ที่เราได้มาคือความยืดหยุ่น เพราะว่าตัวช่วยจะคืนค่าพาธที่ถูกต้องให้เราเสมอ แม้ว่าภายหลังเราจะเปลี่ยนพาธของเส้นทางนั้นๆที่ตัวจัดการเส้นทางไปแล้ว

~~~html
<header class="navbar navbar-default" role="navigation">
  <div class="navbar-header">
    <a class="navbar-brand" href="{{pathFor 'postsList'}}">Microscope</a>
  </div>
</header>

//...
~~~
<%= caption "client/views/application/layout.html"%>
<%= highlight "3" %>

<%= commit "5-1", "Very basic routing." %>

### ก่อนข้อมูลจะมา

ถ้าคุณดีพลอยแอพเวอร์ชั่นปัจจุบัน หรือเปิดดูจากปุ่ม Launch Instance ด้านบน คุณจะสังเกตุเห็นว่ารายชื่อโพสต์จะหายไปขณะหนึ่งแล้วถึงจะปรากฏขึ้น นั่นก็เพราะตอนที่หน้าเพจแรกถูกโหลดมาจะไม่มีข้อมูลโพสต์ใดๆในหน้าจอจนกว่าการบอกรับข้อมูล `posts` จะสิ้นสุดการดึงข้อมูลจากเซิร์ฟเวอร์

ซึ่งในระหว่างที่รอตรงนั้น ถ้าเราบอกผู้ใช้แอพว่า กำลังเกิดอะไรขึ้นและให้รอซักครู่ ก็จะทำให้ผู้ใช้เข้าใจและมีความรู้สึกที่ดีกับแอพเรามากขึ้น

โชคดีที่ Iron Router ช่วยให้เราทำแบบนั้นได้ง่ายๆ โดยเราแค่บอกให้มันรอการบอกรับข้อมูลให้เรียบร้อยเสียก่อน แล้วถึงค่อยทำงานต่อ

โดยเราก็แค่ย้ายการบอกรับข้อมูล `posts` จาก `main.js` มาที่ตัวจัดการเส้นทางแทน

~~~js
Router.configure({
  layoutTemplate: 'layout',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.route('/', {name: 'postsList'});
~~~
<%= caption "lib/router.js" %>
<%= highlight "3" %>

ที่เรากำหนดตรงนี้ก็คือ ในทุกๆเส้นทางของแอพ (ตอนนี้เรามีแค่เส้นทางเดียว แต่ในไม่ช้าเราจะมีเพิ่ม! ) เราต้องการบอกรับข้อมูล `posts`

จุดที่แตกต่างกันของโค้ดตรงนี้กับที่เราเขียนก่อนหน้า (ที่การบอกรับข้อมูลทำใน `main.js` ซึ่งตอนนี้ว่างแล้ว และสามารถลบไฟล์ทิ้งได้) ก็คือ ตอนนี้ Iron Router รู้ว่าเส้นทางจะ "พร้อมใช้" เมื่อข้อมูลที่บอกรับพร้อมใช้งานแล้ว

### กำลังโหลดอยู่นะ

การรู้ว่าเมื่อไรเส้นทาง `postsList` จะพร้อมไม่ได้ทำให้อะไรดีขึ้นถ้าเรายังคงแสดงหน้าเทมเพลทว่างๆอยู่ ก็ต้องขอบคุณ Iron Router ที่มาพร้อมกับวิธีที่จะชะลอการแสดงเทมเพลทจนกว่าเส้นทางจะพร้อม และตอนที่รอนั้นยังสามารถแสดงเทมเพลท `loading` ได้ด้วย ดังนี้ : 

~~~js
Router.configure({
layoutTemplate: 'layout',
loadingTemplate: 'loading',
waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.route('/', {name: 'postsList'});
~~~
<%= caption "lib/router.js" %>
<%= highlight "3,4" %>

สังเกตุด้วยว่าเมื่อเรากำหนดฟังก์ชัน `waitOn` ให้ตัวจัดการเส้นทางรอรับข้อมูล การทำงานตรงนี้จะเกิดขึ้นเพียงครั้งเดียวเมื่อผู้ใช้เปิดเข้าแอพครั้งแรกเท่านั้น หลังจากนั้นข้อมูลก็จะถูกโหลดเข้าไปเก็บในหน่วยความจำเบราว์เซอร์ และตัวจัดการเส้นทางก็ไม่จำเป็นต้องรออีก

ส่วนสุดท้ายที่เราต้องทำคือเทมเพลทขณะโหลดข้อมูล เราจะใช้แพ็คเกจ `spin` มาสร้างภาพเคลื่อนไหวแสดงการโหลด ด้วยการใช้คำสั่ง `meteor add sacha:spin` และสร้างเทมเพลท `loading` ลงในโฟลเดอร์ `client/templates/includes` ดังนี้ : 

~~~html
<template name="loading">
  {{>spinner}}
</template>
~~~
<%= caption "client/templates/includes/loading.html" %>

สังเกตุว่า `{{>spinner}}` เป็นโค้ดตัวช่วยที่อยู่ในแพ็คเกจ `spin` ซึ่งแม้ว่ามันจะอยู่นอกแอพเรา เราก็สามารถเรียกมาใช้งานได้เหมือนเทมเพลทตัวอื่นๆ

การที่เรารอการบอกรับข้อมูลให้เรียบร้อยเป็นเรื่องที่ดี ไม่เพียงแต่ส่งผลต่อการใช้งานเท่านั้น มันยังช่วยให้เราคาดหมายได้ว่าข้อมูลจะพร้อมใช้งานอยู่เสมอจากในเทมเพลท และยังทำให้เราไม่ต้องหาวิธีจัดการกับเทมเพลทเมื่อไม่มีข้อมูล ซึ่งจำเป็นต้องหาทางแก้อยู่เสมอ

<%= commit "5-2", "Wait on the post subscription." %>

<% note do %>

### แวบมาดู Reactivity กันหน่อย

Reactivity คือแกนหลักของ Meteor ซึ่งแม้เราจะยังไม่ได้ไปถึงเรื่องนี้ แต่เทมเพลทแสดงการโหลดก็ช่วยให้เรามองเห็นแนวคิดของเรื่องนี้ได้บ้าง

การเปลี่ยนทิศทางมาเรียกใช้เทมเพลทแสดงการโหลด เมื่อข้อมูลยังไม่ถูกโหลดเข้ามานั้น เป็นเรื่องที่พอเข้าใจได้ แต่หลังจากที่ข้อมูลถูกโหลดมาเรียบร้อยแล้ว ตัวจัดการเส้นทางจะรู้ได้ยังไงว่าเมื่อไรที่จะต้องส่งผู้ใช้ *กลับ* ไปที่หน้าเดิม

ตอนนี้ ตอบได้แค่ว่าต้องใช้วิธีการ Reactivity เข้ามาจัดการ แต่ไม่ต้องกังวลเราจะได้เรียนรู้เรื่องนี้กันมากขึ้น อีกไม่นาน!

<% end %>

### Routing To A Specific Post

////

////

////

~~~html
<template name="postPage">
  {{> postItem}}
</template>
~~~
<%= caption "client/templates/posts/post_page.html" %>

////

////

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.route('/', {name: 'postsList'});
Router.route('/posts/:_id', {
  name: 'postPage'
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "8~10" %>

////

////

////

////

<%= diagram "router-diagram-2", "The data context.", "pull-center" %>

////

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.route('/', {name: 'postsList'});
Router.route('/posts/:_id', {
  name: 'postPage',
  data: function() { return Posts.findOne(this.params._id); }
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "10" %>

////

////

<% note do %>

### More About Data Contexts

////

////

~~~html
{{#each widgets}}
  {{> widgetItem}}
{{/each}}
~~~

////

~~~html
{{#with myWidget}}
  {{> widgetPage}}
{{/with}}
~~~

////

~~~js
{{> widgetPage myWidget}}
~~~

////

<% end %>

### Using a Dynamic Named Route Helper

////

////

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn btn-default">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/templates/posts/post_item.html"%>
<%= highlight "6" %>
<%= commit "5-3", "Routing to a single post page." %>

////

////

////

////

////

<%= screenshot "5-2", "A single post page." %>

<% note do %>

### HTML5 pushState

////

////

////

<% end %>

### Post Not Found

////

////

////

~~~html
<template name="notFound">
<div class="not-found jumbotron">
<h2>404</h2>
<p>Sorry, we couldn't find a page at this address.</p>
</div>
</template>
~~~
<%= caption "client/templates/application/not_found.html"%>

////

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  notFoundTemplate: 'notFound',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

//...
~~~
<%= caption "lib/router.js"%>
<%= highlight "4" %>

////

////

////

~~~js
//...

Router.onBeforeAction('dataNotFound', {only: 'postPage'});
~~~
<%= caption "lib/router.js"%>
<%= highlight "4" %>

////

<%= commit "5-4", "Added not found template." %>

<% note do %>

### Why “Iron”?

////

<% end %>
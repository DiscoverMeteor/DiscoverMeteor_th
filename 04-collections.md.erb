---
title: คอลเลคชั่น
slug: collections
date: 0004/01/01
number: 4
contents: รู้จักคุณสมบัติเรียลไทม์คอลเลคชั่นของ Meteor|เข้าใจวิธีการซิงโครไนซ์ข้อมูลของ Meteor|ใช้คอลเลคชั่นกับเทมเพลทของเรา|เปลี่ยนแอพเราให้ทำงานแบบเรียลไทม์!
paragraphs: 72
---

ในบทที่ 1 เราได้เกริ่นถึงคุณสมบัติหนึ่งของ Meteor เรื่องการซิงโครไนซ์ข้อมูลอัตโนมัติระหว่างไคลเอนต์และเซิร์ฟเวอร์กันไปบ้างแล้ว

ตอนนี้ก็ถึงเวลาที่จะเข้าไปดูในรายละเอียดว่ามันทำงานอย่างไร และทำความเข้าใจการทำงานของ **คอลเลคชั่น** ใน Meteor ซึ่ีงเป็นเทคโนโลยีหลักที่ช่วยให้การทำงานนี้เกิดขึ้นได้ 

คอลเลคชั่นเป็นโครงสร้างข้อมูลแบบพิเศษที่ช่วยเราจัดเก็บข้อมูลลงฐานข้อมูล MongoDB บนเซิร์ฟเวอร์ และช่วยซิงโครไนซ์ข้อมูลแบบเรียลไทม์ระหว่างเซิร์ฟเวอร์กับเบราว์เซอร์ของผู้ใช้แต่ละคนที่เชื่อมต่อเข้ามา

สิ่งที่เราต้องการก็คือ จัดเก็บโพสท์ข่าวลงฐานข้อมูล และแชร์การใช้งานระหว่างผู้ใช้ภายในแอพ ดังนั้นเราจึงเริ่มต้นด้วยการสร้างคอลเลคชั่นชื่อ `Posts` ขึ้นเพื่อใช้เก็บข้อมูลนี้

เนื่องจากเรามักใช้คอลเลคชั่นเป็นศูนย์กลางของแอพ ดังนั้นเราก็ควรวางคอลเลคชั่นไว้ในโฟลเดอร์ `lib` เพื่อให้แน่ใจว่ามันถูกสร้างขึ้นตอนที่แอพเริ่มทำงานเสมอ โดยในแอพของเรานั้น ให้คุณสร้างโฟลเดอร์ย่อย `collections/` ใน `lib` และสร้างไฟล์ `posts.js` ไว้ข้างใน ด้วยโค้ดต่อไปนี้ :

~~~js
Posts = new Meteor.Collection('posts');
~~~
<%= caption "lib/collections/posts.js" %>

<%= commit "4-1", "Added a posts collection" %>

<% note do %>

### ใช้ Var หรือไม่ใช้ Var กันแน่

ใน Meteor นั้น คำสั่ง `var` จะจำกัดการใช้งานของอ็อบเจกต์ไว้เฉพาะในไฟล์ทีี่เรียกใช้เท่านั้น ด้วยเหตุนี้เราจึงสร้างคอลเลคชั่น `Posts` โดยไม่มีคำสั่ง `var` นำหน้า เพื่อให้เราเรียกใช้มันได้จากทุกๆ ที่ในแอพนั่นเอง

<% end %>

### การเก็บข้อมูล

เว็บแอพมีวิธีจัดเก็บข้อมูลพื้นฐานอยู่ 3 รูปแบบ ดังนี้

- **เก็บในหน่วยความจำเบราว์เซอร์ :** ข้อมูลที่เก็บไว้ในหน่วยความจำเบราว์เซอร์อย่างเช่น ตัวแปรจาวาสคริปต์ จะใช้งานได้เฉพาะในแท็บที่จาวาสคริปต์นั้นทำงานอยู่ ไม่ได้ถูกเก็บอย่างถาวร และจะสูญหายไปเมื่อคุณปิดแท็บนั้น

- **เก็บในที่เก็บข้อมูลของเบราว์เซอร์ :** เบราว์เซอร์นั้นสามารถที่จะเก็บข้อมูลให้นานขึ้นได้ด้วยการใช้คุกกี้ หรือที่เก็บข้อมูลส่วนตัว ([Local Storage](http://diveintohtml5.info/storage.html)) แม้ว่าข้อมูลที่เก็บไว้นี้จะคงอยู่ในทุกๆ session ของเบราว์เซอร์ มันก็เข้าถึงได้จากผู้ใช้ปัจจุบันเท่านั้น (จากทุกๆ แท็บที่เปิดใช้)  และก็ไม่ง่ายที่จะแชร์ข้อมูลนี้ให้ผู้ใช้คนอื่น

- **เก็บลงฐานข้อมูลบนเซิร์ฟเวอร์ :** การเก็บลงฐานข้อมูลเป็นทางเลือกที่ดีที่สุด ถ้าคุณต้องการจัดเก็บข้อมูลแบบถาวร และให้ผู้ใช้หลายคนเข้าถึงข้อมูลได้ (ใน Meteor จะใช้ฐานข้อมูล MongoDB เป็นทางเลือกหลัก)

Meteor นั้นใช้การเก็บข้อมูลทั้ง 3 แบบ และในบางครั้งยังทำการซิงโครไนซ์ข้อมูลจากที่หนึ่งไปอีกที่หนึ่งให้ด้วย (เดี๋ยวเราจะได้ดูตัวอย่างกัน) แต่ด้วยข้อดีของฐานข้อมูลตามที่กล่าวมา เราจึงมักใช้ฐานข้อมูลเป็นที่เก็บข้อมูลหลักของระบบกันโดยทั่วไป

### ไคลเอนต์และเซิร์ฟเวอร์

โค้ดที่อยู่นอกโฟลเดอร์ `client` และ `server` จะทำงานทั้งในฝั่งไคลเอนต์และฝั่งเซิร์ฟเวอร์ ดังนั้นคอลเลคชั่น `Posts` จึงถูกเรียกใช้งานได้จากทั้งสองฝั่ง ซึ่งการทำงานของคอลเลคชั่นในแต่ละฝั่งนั้น ก็อาจจะมีความแตกต่างกันออกไป

ในฝั่งเซิร์ฟเวอร์ หน้าที่ของคอลเลคชั่นคือ ติดต่อกับฐานข้อมูล MongoDB อ่านและเขียนข้อมูลที่มีการเปลี่ยนแปลง หรือเปรียบได้กับไลบรารีของระบบฐานข้อมูลทั่วไปนั่นเอง

ส่วนในฝั่งไคลเอนต์ คอลเลคชั่นก็คือสำเนาชุดข้อมูลย่อยของฐานข้อมูลหลัก โดยข้อมูลในคอลเลคชั่นที่ไคลเอนต์จะถูกปรับปรุงให้ตรงกับชุดข้อมูลย่อยนั้นอยู่เสมอ หรือเกือบตลอดเวลา

<% note do %>

### คอนโซล กับ คอนโซล กับ คอนโซล

ในบทนี้ เราจะเริ่มใช้ **คอนโซลของเบราว์เซอร์** ซึ่งเป็นคนละตัวกับ **โปรแกรมเทอร์มินอล** หรือ **โปรแกรมเชลล์ของ Mongo** โดยเราได้ทำสรุปย่อของแต่ละตัวไว้แล้วดังนี้

#### **โปรแกรมเทอร์มินอล**

<%= screenshot "terminal", "The Terminal" %>

- เรียกใช้ได้จากระบบปฏิบัติการ
- **โค้ดที่เซิร์ฟเวอร์** เมื่อใช้คำสั่ง `console.log()` จะแสดงผลออกที่นี่
- พร้อมท์คำสั่ง : `$`
- รู้จักกันในชื่อ : โปรแกรมเชลล์ แบชเชลล์ (Bash) 

#### **คอนโซลของเบราว์เซอร์**

<%= screenshot "browser-console", "The Browser Console" %>

- เรียกใช้ได้จากในเบราว์เซอร์ รันคำสั่งจาวาสคริปต์ได้
- **โค้ดที่ไคลเอนต์** เมื่อใช้คำสั่ง `console.log()` จะแสดงผลออกที่นี่
- พร้อมท์คำสั่ง : `❯`
- รู้จักกันในชื่อ : คอนโซลจาวาสคริปต์ คอนโซลนักพัฒนา (DevTools Console) 

#### **โปรแกรมเชลล์ของ Mongo**

<%= screenshot "mongo-shell", "The Mongo Shell" %>

- เรียกใช้ได้จากโปรแกรมเทอร์มินอล ด้วยคำสั่ง `meteor mongo`
- ช่วยให้คุณเข้าถึงฐานข้อมูลของแอพคุณโดยตรง
- พร้อมท์คำสั่ง : `>`
- รู้จักกันในชื่อ : คอนโซล Mongo

จำไว้ว่า คุณไม่จำเป็นต้องป้อนอักษรพร้อมท์ (`$`, `❯`, or `>`) รวมไปกับคำสั่ง และบรรทัดที่ไม่มีพร้อมท์คำสั่งนำหน้า ก็เป็นการแสดงผลลัพธ์ที่ได้จากคำสั่งก่อนหน้านั้น

<% end %>

### คอลเลคชั่นที่เซิร์ฟเวอร์

ย้อนกลับไปตรงที่เราบอกว่า คอลเลคชั่นที่เซิร์ฟเวอร์ทำหน้าที่เหมือนกับ API ของฐานข้อมูล Mongo นั่นก็คือในโค้ดฝั่งเซิร์ฟเวอร์นั้น คุณสามารถที่จะเขียนคำสั่ง เช่น `Posts.insert()` หรือ `Posts.update()` เพื่อทำการแก้ไขเปลี่ยนแปลงคอลเลคชั่น `posts` ที่เก็บไว้ใน Mongo ได้โดยตรง

เพื่อให้คุณเห็นข้อมูลในตัว Mongo ให้คุณเปิดโปรแกรมเทอร์มินอลขึ้นอีกตัว (พร้อมๆ กับตัวแรกที่คุณเปิดและรันคำสั่ง `meteor` ไว้แล้ว) แล้วไปที่โฟลเดอร์ของแอพคุณ จากนั้นให้รันคำสั่ง `meteor mongo` เพื่อเรียกใช้งานโปรแกรมเชลล์ของ Mongo ซึ่งคุณสามารถป้อนคำสั่งของ Mongo ได้ (คุณสามารถออกจากโปรแกรมด้วยปุ่ม `ctrl+c`) เช่น ลองเพิ่มโพสท์ข่าวเข้าไปใหม่ ด้วยคำสั่งนี้ 

~~~bash
> db.posts.insert({title: "A new post"});

> db.posts.find();
{ "_id": ObjectId(".."), "title" : "A new post"};
~~~
<%= caption "The Mongo Shell" %>

<% note do %>

### เรียกใช้ Mongo จาก Meteor.com

คุณควรรู้ว่า หลังจากที่คุณส่งแอพขึ้นไปรันที่ *.meteor.com แล้ว คุณยังสามารถเรียกใช้โปรแกรมเชลล์ของ Mongo เพื่อเข้าถึงฐานข้อมูลของแอพคุณที่รันอยู่ได้ ด้วยคำสั่ง `meteor mongo myApp` 

และคุณก็ยังสามารถเรียกดูล็อกของแอพคุณได้ ด้วยคำสั่ง `meteor logs myApp`

<% end %>

รูปแบบคำสั่งของ Mongo นั้นดูคุ้นเคยดี เพราะเป็นจาวาสคริปต์ โดยเราคงไม่ใช้โปรแกรมเชลล์ของ Mongo ทำอะไรกับข้อมูลไปมากกว่านี้ เราเพียงแค่ใช้มันตรวจดูข้อมูลบ้างเพื่อให้แน่ใจว่ามันเป็นไปอย่างที่เราคิดไว้

### คอลเลคชั่นที่ไคลเอนต์

การใช้คอลเลคชั่นที่ฝั่งไคลเอนต์มีอะไรที่มากกว่านั้น เมื่อคุณกำหนดให้ `Posts = new Mongo.Collection('posts');` ที่ไคลเอนต์ ก็เท่ากับคุณได้สร้าง*แคชข้อมูลในเบราว์เซอร์*จากข้อมูลจริงในคอลเลคชั่นของฐานข้อมูล Mongo  โดย "แคช" ในความหมายของเราก็คือ คอลเลคชั่นของชุดข้อมูลย่อย ที่คุณสามารถเรียกมาใช้งานได้อย่าง*รวดเร็ว*

เรื่องสำคัญที่ควรรู้เพื่อให้เข้าใจพื้นฐานการทำงานของ Meteor ก็คือ คอลเลคชั่นที่ไคลเอนต์ประกอบด้วยชุดข้อมูลย่อยของเอกสารที่เก็บไว้ในคอลเลคชั่น Mongo (เหตุผลก็คือ เราไม่ต้องการส่งข้อมูลทั้งหมดจากฐานข้อมูลไปไว้ที่ไคลเอนต์)

และเอกสารในชุดข้อมูลย่อยนี้ ถูกเก็บไว้ในหน่วยความจำของเบราว์เซอร์ ทำให้เราเรียกใช้งานได้ทันที ไม่ต้องรอข้อมูลจากเซิร์ฟเวอร์ หรือรอฐานข้อมูลดึงข้อมูลมาให้อีก เมื่อคุณเรียกคำสั่ง `Posts.find()` ที่ไคลเอนต์ ข้อมูลที่เตรียมไว้ล่วงหน้าก็พร้อมใช้งานแล้ว

<% note do %>

### รู้จัก MiniMongo

เราเรียกโค้ดของ Meteor ที่จัดการฐานข้อมูล Mongo ในฝั่งไคลเอนต์ ว่า MiniMongo ซึ่งมันยังไม่สมบูรณ์แบบเท่าไหร่ และคุณอาจพบว่าไม่สามารถใช้คุณสมบัติบางอย่างของ Mongo กับ MiniMongo ได้ แต่ก็ไม่มีอะไรที่น่าเป็นห่วง เพราะในหนังสือเล่มนี้เราใช้งานเฉพาะคุณสมบัติที่ทำงานได้ทั้งบน Mongo และ MiniMongo เท่านั้น

<% end %>

### การสื่อสารระหว่างไคลเอนต์กับเซิร์ฟเวอร์

หัวใจของเรื่องทั้งหมด ก็คือคอลเลคชั่นที่ไคลเอนต์ทำการซิงโครไนซ์ข้อมูลกับคอลเลคชั่นชื่อเดียวกัน (ในแอพเราคือ `posts`) บนเซิร์ฟเวอร์ได้อย่างไร 

แทนที่จะอธิบายลงรายละเอียดในเรื่องนี้ เรามาลองทำไปด้วยกัน แล้วสังเกตุจากสิ่งที่เกิดขึ้น น่าจะทำให้เราเข้าใจได้ดีกว่า

เริ่มจากเปิดเบราว์เซอร์ขึ้นสองหน้าต่าง แล้วเปิดใช้คอนโซลของบราวเซอร์ทั้งสองตัว จากนั้นให้เปิดเชลล์ของ Mongo จากคอมมานด์ไลน์

ตอนนี้เราจะลองค้นหาเอกสารที่เราได้สร้างไว้ก่อนหน้า โดยป้อนคำสั่งต่อไปนี้เข้าไปในโปรแกรมที่ระบุ (ถ้าสังเกตุดีๆ จะเห็นว่าหน้าจอของแอพเรายังคงแสดงผลรายการโพสท์ข่าวแค่สามตัว ตอนนี้ยังไม่ต้องสนใจอะไร ผ่านไปก่อน)

~~~bash
> db.posts.find();
{title: "A new post", _id: ObjectId("..")};
~~~
<%= caption "ในเชลล์ของ Mongo" %>

~~~js
❯ Posts.findOne();
{title: "A new post", _id: LocalCollection._ObjectID};
~~~
<%= caption "ในคอนโซลของเบราว์เซอร์ตัวแรก" %>

ลองสร้างโพสท์ข่าวใหม่ โดยป้อนคำสั่งต่อไปนี้ลงในคอนโซลของเบราว์เซอร์

~~~js
❯ Posts.find().count();
1
❯ Posts.insert({title: "A second post"});
'xxx'
❯ Posts.find().count();
2
~~~
<%= caption "ในคอนโซลของเบราว์เซอร์ตัวแรก" %>

เป็นไปตามที่คาด โพสท์ข่าวได้ถูกสร้างเข้าไปในคอลเลคชั่นที่ไคลเอนต์แล้ว ตอนนี้ลองเช็คดูที่ Mongo ว่าเป็นยังไง

~~~bash
❯ db.posts.find();
{title: "A new post", _id: ObjectId("..")};
{title: "A second post", _id: 'yyy'};
~~~
<%= caption "ในเชลล์ของ Mongo" %>

จากที่เห็น โพสท์ข่าวถูกส่งกลับไปเก็บที่ฐานข้อมูล Mongo ด้วย โดยที่เราไม่ต้องเขียนโค้ดจัดการตรงนี้แม้แต่บรรทัดเดียว (อันที่จริงเราเขียนไปแล้ว *หนึ่ง* บรรทัด: `new Mongo.Collection('posts')`)

ยิ่งไปกว่านั้น! ถ้าเราป้อนคำสั่งต่อไปนี้ในคอนโซลของเบราว์เซอร์ตัวที่สอง 

~~~js
❯ Posts.find().count();
2
~~~
<%= caption "ในคอนโซลของเบราว์เซอร์ตัวที่สอง" %>

โพสท์ข่าวก็ไปอยู่ที่นั่นด้วย! โดยเราไม่ต้องกดรีเฟรชหรือทำอะไรกับเบราว์เซอร์ตัวที่สองเลย ทั้งเราก็ไม่ได้เขียนโค้ดอะไรที่จะส่งข้อมูลนี้ออกมาด้วย มันเกิดขึ้นได้เองอย่างกับมีเวทย์มนต์ และในทันทีทันใด แม้ว่าคุณจะสังเกตุได้ในภายหลังก็ตาม 

สิ่งที่เกิดขึ้นก็คือ คอลเลคชั่นฝั่งเซิร์ฟเวอร์ถูกแจ้งจากไคลเอนต์ว่ามีโพสท์ใหม่เกิดขึ้น และรับหน้าที่กระจายโพสท์นี้ไปที่ฐานข้อมูล Mongo และส่งกลับไปยังคอลเลคชั่น `post` ตัวอื่นๆที่ได้เชื่อมต่อไว้

การดึงโพสท์ข่าวด้วยคำสั่งในคอนโซลของเบราว์เซอร์ไม่ได้ช่วยอะไรเรามากนัก งานต่อไปที่เราจะทำกันคือ เรียนรู้วิธีการผูกข้อมูลนี้เข้ากับเทมเพลท และเปลี่ยนแอพแบบง่ายๆของเราให้กลายเป็นเว็บแอพแบบเรียลไทม์

### สร้างข้อมูลลงในฐานข้อมูล

ในเมื่อเรารู้วิธีดึงข้อมูลจากคอลเลคชั่นด้วยคอนโซลของเบราว์เซอร์กันไปแล้ว สิ่งที่เราจะทำต่อก็คือนำข้อมูลนั้นมาแสดงผลบนหน้าจอ และปรับการแสดงผลเมื่อข้อมูลมีการเปลี่ยนแปลง โดยเราจะเปลี่ยนแอพที่เป็นแค่ *หน้าเว็บ* ง่ายๆ แสดงผลได้แค่ข้อมูลนิ่งๆ ให้กลายเป็น *เว็บแอพ* แบบเรียลไทม์ ที่แสดงข้อมูลแบบแปรเปลี่ยนได้ตามจริง

สิ่งแรกที่เราจะทำคือ ใส่ข้อมูลลงในฐานข้อมูล โดยเราจะใช้ไฟล์ที่มีชุดข้อมูลตัวอย่างโหลดข้อมูลเข้าไปในคอลเลคชั่น `Posts` เมื่อเซิร์ฟเวอร์เริ่มทำงาน

ก่อนอื่นเราต้องทำให้แน่ใจว่าไม่มีอะไรในฐานข้อมูล ด้วยการเรียกใช้คำสั่ง `meteor reset` เพื่อลบฐานข้อมูลของคุณและรีเซ็ทแอพใหม่ ซึ่งคุณต้องระมัดระวังการใช้คำสั่งนี้ให้มาก หากคุณกำลังพัฒนาแอพจริงๆ อยู่

ปิดการทำงานของเซิร์ฟเวอร์ Meteor (ด้วยปุ่ม `ctrl-c`) และรันคำสั่งต่อไปนี้ ในคอมมานด์ไลน์

~~~bash
$ meteor reset
~~~

คำสั่งรีเซ็ตนี้จะลบทุกอย่างในฐานข้อมูล Mongo ซึ่งมีประโยชน์มากในตอนที่กำลังทำแอพ แล้วฐานข้อมูลของเราเกิดรวนขึ้นมา

ถึงเวลารันแอพเราอีกครั้งได้แล้ว

~~~bash
meteor
~~~

เมื่อฐานข้อมูลว่างแล้ว ตอนนี้เราก็จะใส่โค้ดที่จะทำการโหลดโพสท์ข่าวสามข่าวเข้าไปตอนเซิร์ฟเวอร์เริ่มทำงาน โดยกำหนดเงื่อนไขว่าให้โหลดเมื่อคอลเลคชั่น `Posts` ว่างอยู่เท่านั้น

~~~js
if (Posts.find().count() === 0) {
  Posts.insert({
    title: 'Introducing Telescope',
    url: 'http://sachagreif.com/introducing-telescope/'
  });
  
  Posts.insert({
    title: 'Meteor',
    url: 'http://meteor.com'
  });
  
  Posts.insert({
    title: 'The Meteor Book',
    url: 'http://themeteorbook.com'
  });
}
~~~
<%= caption "server/fixtures.js" %>

<%= commit "4-2", "Added data to the posts collection." %>

ที่เราวางไฟล์นี้ไว้ในโฟลเดอร์ `server/` ก็เพราะไม่ต้องการให้เบราว์เซอร์โหลดมันไปใช้ โดยโค้ดจะทำงานทันที่ที่เซิร์ฟเวอร์เริ่มทำงาน และเรียกคำสั่ง `insert` เพื่อเพิ่มโพสท์ข่าวสามโพสท์เข้าไปที่คอลเลคชั่น `Posts` ในฐานข้อมูล

ตอนนี้คุณก็รันเซิร์ฟเวอร์อีกครั้งด้วยคำสั่ง `meteor` โพสท์ข่าวทั้งสามก็จะเข้าไปอยู่ในฐานข้อมูล

### ข้อมูลแบบไดนามิก

ถ้าเราเปิดคอนโซลของเบราว์เซอร์ เราจะเห็นว่าโพสท์ข่าวใหม่ทั้งสามถูกโหลดเข้ามาใน MiniMongo ด้วยคำสั่งนี้

~~~js
❯ Posts.find().fetch();
~~~
<%= caption "Browser console" %>

เพื่อเปลี่ยนโพสท์พวกนี้ให้เป็น HTML เราก็ต้องใช้ตัวช่วยเทมเพลท

ในบทที่ 3 เรารู้ว่า Meteor ยอมให้เราผูก *เนื้อข้อมูล* เข้ากับเทมเพลท Spacebars เพื่อสร้างหน้า HTML ของข้อมูลแบบง่ายๆ ที่เราจะทำตอนนี้ก็คล้ายๆกัน เราแค่เปลี่ยนข้อมูลนิ่งๆ ในอ็อบเจกต์ `postsData` ไปเป็นคอลเลคชั่นแบบไดนามิก

ด้วยการลบโค้ดส่วนของ `postsData` ออกไป แล้วก็แก้ไข `posts_list.js` ให้เป็นตามนี้

~~~js
Template.postsList.helpers({
  posts: function() {
    return Posts.find();
  }
});
~~~
<%= caption "client/views/posts/posts_list.js" %>
<%= highlight "2~4" %>

<%= commit "4-3", "Wired collection into `postsList` template." %>

<% note do %>

### ค้นหาแล้วดึงมาใช้

ใน Meteor คำสั่ง `find()` จะคืนค่า*เคอร์เซอร์* ของชุดข้อมูลแบบรีแอคทีฟ ([reactive data source](http://docs.meteor.com/#find)) กลับมา และเมื่อเราต้องการใช้ข้อมูลนั้น ก็ใช้คำสั่ง `fetch()` กับเคอร์เซอร์เพื่อแปลงให้มันเป็นอาร์เรย์

ส่วนการทำงานในแอพนั้น Meteor ก็ฉลาดพอที่จะรู้ว่าจะเรียกข้อมูลจากเคอร์เซอร์มาใช้ได้อย่างไร โดยไม่ต้องแปลงให้เป็นอาร์เรย์ก่อน ด้วยเหตุนี้คุณถึงไม่ค่อยเห็นคำสั่ง `fetch()` มากนักในโค้ดของ Meteor (และเราก็ไม่ได้ใช้มันในตัวอย่างข้างบนด้วย)

<% end %>

แทนที่เราจะคืนข้อมูลโพสท์ข่าวให้ตัวช่วยเทมเพลท `posts` ด้วยอาร์เรย์นิ่งๆ จากตัวแปร เราก็จะใช้ค่าเคอร์เซอร์ที่ได้มาส่งกลับไปแทน (เหตุที่หน้าจอดูไม่ต่างไปจากเดิม ก็เพราะเรายังคงใช้ข้อมูลชุดเดิมอยู่)

<%= screenshot "4-3", "Using live data" %>

การทำงานเกิดขึ้นเมื่อคอลเลคชั่นที่เซิร์ฟเวอร์ดึงโพสท์ข่าวมาจาก Mongo และส่งมันต่อให้กับคอลเลคชั่นที่ไคลเอนต์ จากนั้นตัวช่วยของ Spacebars ก็จะส่งต่อให้กับเทมเพลท ซึ่งคำสั่ง `{{#each}}` ในเทมเพลท ก็จะทำงานซ้ำเท่ากับจำนวนรายการใน `Posts` และแสดงข้อมูลออกไปที่หน้าจอ

ตอนนี้เรามาลองเพิ่มโพสท์ข่าวเข้าไปด้วยคอนโซลของเบราว์เซอร์ ดังนี้

~~~js
❯ Posts.insert({
  title: 'Meteor Docs',
  author: 'Tom Coleman',
  url: 'http://docs.meteor.com'
});
~~~
<%= caption "Browser console" %>

เมื่อดูที่เบราว์เซอร์ คุณก็ควรจะเห็นแบบนี้

<%= screenshot "4-4", "Adding posts via the console" %>

สิ่งที่คุณเห็นเป็นครั้งแรกนี้คือการทำงานแบบรีแอคทีฟ เกิดจากที่เราบอกให้ Spacebars ทำงานซ้ำๆตามจำนวนของข้อมูลในเคอร์เซอร์ที่ได้จากคำสั่ง `Posts.find()`  เมื่อใดที่มีการเปลี่ยนแปลงเกิดขึ้นที่เคอร์เซอร์นี้ ก็ให้ทำการปรับหน้า HTML ด้วยวิธีที่ง่ายที่สุด เพื่อแสดงข้อมูลที่ถูกต้องออกหน้าจอทันที

<% note do %>

### มาสำรวจการเปลี่ยนแปลงของ DOM กัน

ในกรณีนี้, วิธีที่ง่ายที่สุดที่ Spacebars จะเปลี่ยนแปลง DOM ก็คือ การเพิ่มแท็ก `<div class="post">...</div>` เข้าไป โดยถ้าคุณอยากจะรู้ว่าเกิดอะไรขึ้นจริงๆ ให้เปิดตัวสำรวจ DOM ที่เบราว์เซอร์ และคลิ๊กเลือกที่ `<div>` ของโพสท์ข่าวไว้ตัวนึง

จากนั้นให้เพิ่มโพสท์ข่าวใหม่เข้าไปทางคอนโซลจาวาสคริปต์ เมื่อคุณเปิดกลับไปที่แท็บของตัวสำรวจ DOM อีกครั้ง คุณจะเห็นว่ามี `<div>` ใหม่เกิดขึ้นตรงกับโพสท์ข่าวใหม่นั้น โดยที่โพสท์ข่าวตัวที่คุณคลิ๊กเลือกไว้ตอนแรกก็ยังถูกเลือกอยู่ ที่เห็นนี้็ก็คือวิธีที่ Spacebars ปรับหน้า HTML ด้วยการเพิ่มแท็กเข้าไปใหม่โดยไม่ยุ่งกับแท็กเดิม

<% end %>

### Connecting Collections: Publications and Subscriptions

////

////

~~~bash
$ meteor remove autopublish
~~~

////

////

////

~~~js
Meteor.publish('posts', function() {
  return Posts.find();
});
~~~
<%= caption "server/publications.js" %>

////

~~~js
Meteor.subscribe('posts');
~~~
<%= caption "client/main.js" %>

<%= commit "4-4", "Removed `autopublish` and set up a basic publication." %>

////

### Conclusion

////

---
title: การทำงานแบบรีแอคทีฟ
slug: reactivity
date: 0006/01/02
number: 6.5
points: 5
sidebar: true
photoUrl: http://www.flickr.com/photos/ikewinski/9632550278/
photoAuthor: Mike Lewinski
contents: เรียนรู้การทำงานแบบรีแอคทีฟของ Meteor|เข้าใจว่าทำไมต้องใช้วิธี declarative|รู้วิธีเขียนโค้ดที่ใช้ข้อมูลชนิดรีแอคทีฟ
paragraphs: 20
---

ถ้าคอลเลคชั่นเป็นแกนคุณสมบัติหลักของ Meteor แล้ว *การทำงานแบบรีแอคทีฟ (reactivity)* ก็คือ เปลือกหุ้มที่ทำให้แกนนั้นใช้ประโยชน์ได้นั่นเอง

คอลเลคชั่นได้เปลี่ยนแปลงวิธีการทำงานของแอปพลิเคชันเมื่อมีการแก้ไขข้อมูลไปอย่างสิ้นเชิง มันไม่ใช่แค่วิธีการตรวจสอบการเปลี่ยนแปลงข้อมูล (เช่น ด้วยการเรียกใช้ AJAX) และปรับแก้ไขหน้า HTML เท่านั้น แต่ Meteor ทำให้เมื่อใดก็ตามที่ข้อมูลมีการเปลี่ยนแปลงหน้าจอการใช้งานของคุณก็จะปรับเปลี่ยนตามไปด้วยอย่างต่อเนื่อง

ลองหยุดคิดกันซักนิดจะพบว่า เบื้องหลังการทำงานนั้น Meteor สามารถที่จะเปลี่ยนแปลง *ส่วนหนึ่งส่วนใด* ของหน้าจอเมื่อมีการเปลี่ยนแปลงของคอลเลคชั่นเกิดขึ้นได้

โดยถ้าเรา *ใช้วิธีการเขียนโค้ด (imperative)* ให้ทำงานแบบนี้ เราก็ต้องใช้ฟังก์ชัน `.observe()` ของเคอร์เซอร์เรียกใช้ฟังก์ชัน callback เมื่อเอกสารที่ตรงกับเคอร์เซอร์นั้นมีการเปลี่ยนแปลง จากนั้นเราก็แก้ไขข้อมูลกับ DOM (ส่วนของ HTML ที่ถูกสร้างขึ้นในหน้าเว็บเรา) ผ่านฟังก์ชัน callback เหล่านั้น ซึ่งโค้ดที่ได้ก็จะดูคล้ายๆแบบนี้

~~~js
Posts.find().observe({
  added: function(post) {
    // when 'added' callback fires, add HTML element
    $('ul').append('<li id="' + post._id + '">' + post.title + '</li>');
  },
  changed: function(post) {
    // when 'changed' callback fires, modify HTML element's text
    $('ul li#' + post._id).text(post.title);
  },
  removed: function(post) {
    // when 'removed' callback fires, remove HTML element
    $('ul li#' + post._id).remove();
  }
});
~~~

คุณก็พอจะมองออกได้ว่าโค้ดที่ใช้จะซับซ้อนขึ้นอย่างรวดเร็วแค่ไหน ลองคิดดูว่าถ้าต้องเปลี่ยนค่าแต่ละ *ฟิลด์* ของข่าว และยังต้องปรับแก้ไข HTML ที่ซับซ้อนในแท็ก `<li>` ของข่าวนั้นด้วย นี่ยังไม่ได้พูดถึงในกรณีที่มันซับซ้อนสุดๆ เมื่อเราเริ่มผูกแหล่งข้อมูลหลายๆตัวที่เปลี่ยนแปลงค่าได้แบบเรียลไทม์เลยนะ

<% note do %>

### เรา *ควร* ใช้ `observe()` ตอนไหน

การใช้รูปแบบการโค้ดข้างบนนั้นบางทีก็จำเป็น โดยเฉพาะเมื่อต้องเกี่ยวข้องกับโค้ดจากที่อื่น (third-party widgets) ตัวอย่างเช่น ถ้าเราต้องการปักหรือถอนหมุดบนแผนที่แบบเรียลไทม์ด้วยข้อมูลจากคอลเลคชั่น (เพื่อแสดงตำแหน่งที่ผู้ใช้ล็อกอินเข้ามา)

ในกรณีนี้ เราจำเป็นต้องใช้ `.observe()` เพื่อทำให้แผนที่ "คุย" กับคอลเลคชั่นใน Meteor ได้ และรู้ว่าจะทำอย่างไรเมื่อข้อมูลเปลี่ยนไป เช่น คุณอาจจะใช้ฟังก์ชัน callback `added` และ `removed` เพื่อเรียกเมธอด `dropPin()` หรือ `removePin()` จาก API ของแผนที่

<% end %>

### A Declarative Approach

////

////

////

~~~html
<template name="postsList">
  <ul>
    {{#each posts}}
      <li>{{title}}</li>
    {{/each}}
  </ul>
</template>
~~~

////

~~~js
Template.postsList.helpers({
  posts: function() {
    return Posts.find();
  }
});
~~~

////

### Dependency Tracking in Meteor: Computations

////

////

////

////

////

### Setting Up a Computation

////

~~~js
Meteor.startup(function() {
  Tracker.autorun(function() {
    console.log('There are ' + Posts.find().count() + ' posts');
  });
});
~~~

////

////

~~~js
> Posts.insert({title: 'New Post'});
There are 4 posts.
~~~

////
